import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";

// Security: Get current directory safely
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
Generated at: ${new Date().toISOString()}
*/`;

// Security: Validate environment and arguments
const validModes = ['production', 'development'];
const mode = process.argv[2] || 'development';

if (!validModes.includes(mode)) {
  console.error(`âŒ Invalid build mode: ${mode}. Valid modes: ${validModes.join(', ')}`);
  process.exit(1);
}

const isProd = mode === 'production';

console.log(`ğŸ”§ Building in ${mode} mode...`);

// Security: Define allowed external dependencies explicitly
const allowedExternals = [
  'obsidian',
  'electron',
  '@codemirror/autocomplete',
  '@codemirror/collab', 
  '@codemirror/commands',
  '@codemirror/language',
  '@codemirror/lint',
  '@codemirror/search',
  '@codemirror/state',
  '@codemirror/view',
  '@lezer/common',
  '@lezer/highlight',
  '@lezer/lr',
  ...builtins
];

// Security: Validate entry point exists
const entryPoint = resolve(__dirname, 'main.ts');

try {
  const config = {
    banner: {
      js: banner,
    },
    entryPoints: [entryPoint],
    bundle: true,
    external: allowedExternals,
    format: 'cjs',
    target: 'es2018',
    logLevel: 'info',
    sourcemap: isProd ? false : 'inline',
    treeShaking: true,
    outfile: resolve(__dirname, 'main.js'),
    
    // Security enhancements
    minify: isProd,
    keepNames: !isProd, // Preserve function names for debugging
    metafile: isProd,   // Generate metadata for analysis
    
    // Performance optimizations
    splitting: false,   // Obsidian plugins should be single file
    platform: 'neutral',
    
    // Security: Strict error handling
    logOverride: {
      'unsupported-feature': 'error',
      'import-is-undefined': 'error',
    },
    
    // Security: Define globals to prevent accidental usage
    define: {
      'process.env.NODE_ENV': JSON.stringify(mode),
      'global': 'globalThis', // Safer than window
    },
    
    // Security: Plugin to validate imports
    plugins: [
      {
        name: 'security-validator',
        setup(build) {
          // Validate that we only import allowed modules
          build.onResolve({ filter: /.*/ }, (args) => {
            if (args.kind === 'import-statement' || args.kind === 'require-call') {
              const isExternal = allowedExternals.some(ext => 
                args.path === ext || args.path.startsWith(ext + '/')
              );
              
              const isRelative = args.path.startsWith('./') || args.path.startsWith('../');
              const isAbsolute = args.path.startsWith('/');
              
              // Security: Block absolute paths and validate imports
              if (isAbsolute) {
                return {
                  errors: [{
                    text: `âŒ Security: Absolute imports not allowed: ${args.path}`,
                    location: null,
                  }]
                };
              }
              
              // Allow relative imports and external modules
              if (isRelative || isExternal) {
                return null; // Let esbuild handle it
              }
              
              // Log potentially unsafe imports
              if (!isExternal && !isRelative) {
                console.warn(`âš ï¸  Potentially unsafe import: ${args.path}`);
              }
            }
            return null;
          });
          
          // Log build completion
          build.onEnd((result) => {
            if (result.errors.length === 0) {
              console.log(`âœ… Build completed successfully in ${mode} mode`);
              if (isProd && result.metafile) {
                const bundleSize = Object.values(result.metafile.outputs)[0]?.bytes || 0;
                console.log(`ğŸ“¦ Bundle size: ${(bundleSize / 1024).toFixed(2)} KB`);
              }
            } else {
              console.error(`âŒ Build failed with ${result.errors.length} error(s)`);
            }
          });
        }
      }
    ]
  };

  const context = await esbuild.context(config);

  // Security: Proper error handling and cleanup
  const cleanup = async () => {
    console.log('ğŸ§¹ Cleaning up...');
    await context.dispose();
    process.exit(0);
  };

  // Security: Handle process signals properly
  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('unhandledRejection', (reason, promise) => {
    console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
    cleanup();
  });

  if (isProd) {
    console.log('ğŸš€ Starting production build...');
    const result = await context.rebuild();
    
    if (result.errors.length === 0) {
      console.log('âœ… Production build completed successfully!');
    }
    
    await context.dispose();
    process.exit(0);
  } else {
    console.log('ğŸ‘€ Starting development watch mode...');
    console.log('Press Ctrl+C to stop watching...');
    await context.watch();
  }

} catch (error) {
  console.error('âŒ Build configuration error:', error);
  process.exit(1);
}